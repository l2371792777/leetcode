## 319.灯泡开关
Medium  
初始时有 ``n`` 个灯泡处于关闭状态。第一轮，你将会打开所有灯泡。接下来的第二轮，你将会每两个灯泡关闭一个。

第三轮，你每三个灯泡就切换一个灯泡的开关（即，打开变关闭，关闭变打开）。第 ``i`` 轮，你每 ``i`` 个灯泡就切换一个灯泡的开关。直到第 ``n`` 轮，你只需要切换最后一个灯泡的开关。

找出并返回 ``n`` 轮后有多少个亮着的灯泡。

 

示例 1：

<img alt="" src="https://assets.leetcode.com/uploads/2020/11/05/bulb.jpg" style="width: 421px; height: 321px;" />

```

输入：n = 3
输出：1 
解释：
初始时, 灯泡状态 [关闭, 关闭, 关闭].
第一轮后, 灯泡状态 [开启, 开启, 开启].
第二轮后, 灯泡状态 [开启, 关闭, 开启].
第三轮后, 灯泡状态 [开启, 关闭, 关闭]. 

你应该返回 1，因为只有一个灯泡还亮着。

```

示例 2：

```

输入：n = 0
输出：0

```

示例 3：

```

输入：n = 1
输出：1

```

 

提示：

<ul>
	<li>``0 <= n <= 109``</li>
</ul>

### 题解:  
* 思路  
	* 打印所有输出找规律  
	* 数论，开关被切换多少次取决于约数个数，K的约数个数为奇数时，k开启状态，若``x位k的约数``，那么``k/x必定也是K的约数``，k的约数为偶数的情况仅限于K为完全平方数
* 代码  
```c++
	int bulbSwitch(int n)
    {
        if (n == 0)
        {
            return n;
        }
        int pos = 0;
        int res = 1;
        n = n - 2;
        //01000
        while (n >= 5)
        {
            n = n - 5;
            n = n - pos * 2;
            pos++;
        }
        if (n > 1)
        {
            pos++;
        }
        return res + pos;
    }
```